<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Hexo | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="TypeScript知识点语言特性TypeScript 是一种给 JavaScript 添加特性的语言扩展。增加的功能包括：  类型批注和编译时类型检查 类型推断 类型擦除 接口 枚举 Mixin 泛型编程 名字空间 元组 Await  以下功能是从 ECMA 2015 反向移植而来：  类 模块 lambda 函数的箭头语法 可选参数以及默认参数  安装1npm install -g types">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2020/12/21/TypeScript%E7%9F%A5%E8%AF%86%E7%82%B9/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="TypeScript知识点语言特性TypeScript 是一种给 JavaScript 添加特性的语言扩展。增加的功能包括：  类型批注和编译时类型检查 类型推断 类型擦除 接口 枚举 Mixin 泛型编程 名字空间 元组 Await  以下功能是从 ECMA 2015 反向移植而来：  类 模块 lambda 函数的箭头语法 可选参数以及默认参数  安装1npm install -g types">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-12-21T06:47:11.062Z">
<meta property="article:modified_time" content="2020-12-21T06:47:11.065Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2020/12/21/TypeScript%E7%9F%A5%E8%AF%86%E7%82%B9/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-12-21 14:47:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a></div></div></div><hr/></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-21T06:47:11.062Z" title="发表于 2020-12-21 14:47:11">2020-12-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-12-21T06:47:11.065Z" title="更新于 2020-12-21 14:47:11">2020-12-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="TypeScript知识点"><a href="#TypeScript知识点" class="headerlink" title="TypeScript知识点"></a>TypeScript知识点</h1><h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><p>TypeScript 是一种给 JavaScript 添加特性的语言扩展。增加的功能包括：</p>
<ul>
<li>类型批注和编译时类型检查</li>
<li>类型推断</li>
<li>类型擦除</li>
<li>接口</li>
<li>枚举</li>
<li>Mixin</li>
<li>泛型编程</li>
<li>名字空间</li>
<li>元组</li>
<li>Await</li>
</ul>
<p>以下功能是从 ECMA 2015 反向移植而来：</p>
<ul>
<li>类</li>
<li>模块</li>
<li>lambda 函数的箭头语法</li>
<li>可选参数以及默认参数</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure>
<h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">编译参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1.</td>
<td align="center"><strong>–help</strong>显示帮助信息</td>
</tr>
<tr>
<td align="center">2.</td>
<td align="center"><strong>–module</strong>载入扩展模块</td>
</tr>
<tr>
<td align="center">3.</td>
<td align="center"><strong>–target</strong>设置 ECMA 版本</td>
</tr>
<tr>
<td align="center">4.</td>
<td align="center"><strong>–declaration</strong>额外生成一个 .d.ts 扩展名的文件。<code>tsc ts-hw.ts --declaration</code>以上命令会生成 ts-hw.d.ts、ts-hw.js 两个文件。</td>
</tr>
<tr>
<td align="center">5.</td>
<td align="center"><strong>–removeComments</strong>删除文件的注释</td>
</tr>
<tr>
<td align="center">6.</td>
<td align="center"><strong>–out</strong>编译多个文件并合并到一个输出的文件</td>
</tr>
<tr>
<td align="center">7.</td>
<td align="center"><strong>–sourcemap</strong>生成一个 sourcemap (.map) 文件。sourcemap 是一个存储源代码与编译代码对应位置映射的信息文件。</td>
</tr>
<tr>
<td align="center">8.</td>
<td align="center"><strong>–module noImplicitAny</strong>在表达式和声明上有隐含的 any 类型时报错</td>
</tr>
<tr>
<td align="center">9.</td>
<td align="center"><strong>–watch</strong>在监视模式下运行编译器。会监视输出文件，在它们改变时重新编译。</td>
</tr>
</tbody></table>
<h2 id="TypeScript-基础类型"><a href="#TypeScript-基础类型" class="headerlink" title="TypeScript 基础类型"></a>TypeScript 基础类型</h2><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">关键字</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">任意类型</td>
<td align="center">any</td>
<td align="center">声明为 any 的变量可以赋予任意类型的值。</td>
</tr>
<tr>
<td align="center">数字类型</td>
<td align="center">number</td>
<td align="center">双精度 64 位浮点值。它可以用来表示整数和分数。<code>let binaryLiteral: number = 0b1010; // 二进制 let octalLiteral: number = 0o744;    // 八进制 let decLiteral: number = 6;    // 十进制 let hexLiteral: number = 0xf00d;    // 十六进制</code></td>
</tr>
<tr>
<td align="center">字符串类型</td>
<td align="center">string</td>
<td align="center">一个字符系列，使用单引号（**’<strong>）或双引号（</strong>“<strong>）来表示字符串类型。反引号（</strong><code>**）来定义多行文本和内嵌表达式。</code>let name: string = “Runoob”; let years: number = 5; let words: string = <code>您好，今年是 $&#123; name &#125; 发布 $&#123; years + 1&#125; 周年</code>;`</td>
</tr>
<tr>
<td align="center">布尔类型</td>
<td align="center">boolean</td>
<td align="center">表示逻辑值：true 和 false。<code>let flag: boolean = true;</code></td>
</tr>
<tr>
<td align="center">数组类型</td>
<td align="center">无</td>
<td align="center">声明变量为数组。<code>// 在元素类型后面加上[] let arr: number[] = [1, 2]; // 或者使用数组泛型 let arr: Array&lt;number&gt; = [1, 2];</code></td>
</tr>
<tr>
<td align="center">元组</td>
<td align="center">无</td>
<td align="center">元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同。<code>let x: [string, number]; x = [&#39;Runoob&#39;, 1];    // 运行正常 x = [1, &#39;Runoob&#39;];    // 报错 console.log(x[0]);    // 输出 Runoob</code></td>
</tr>
<tr>
<td align="center">枚举</td>
<td align="center">enum</td>
<td align="center">枚举类型用于定义数值集合。<code>enum Color &#123;Red, Green, Blue&#125;; let c: Color = Color.Blue; console.log(c);    // 输出 2</code></td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">void</td>
<td align="center">用于标识方法返回值的类型，表示该方法没有返回值。<code>function hello(): void &#123;    alert(&quot;Hello Runoob&quot;); &#125;</code></td>
</tr>
<tr>
<td align="center">null</td>
<td align="center">null</td>
<td align="center">表示对象值缺失。</td>
</tr>
<tr>
<td align="center">undefined</td>
<td align="center">undefined</td>
<td align="center">用于初始化变量为一个未定义的值</td>
</tr>
<tr>
<td align="center">never</td>
<td align="center">never</td>
<td align="center">never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。</td>
</tr>
</tbody></table>
<h2 id="TypeScript-变量声明"><a href="#TypeScript-变量声明" class="headerlink" title="TypeScript 变量声明"></a>TypeScript 变量声明</h2><h3 id="TypeScript-变量的命名规则"><a href="#TypeScript-变量的命名规则" class="headerlink" title="TypeScript 变量的命名规则"></a>TypeScript 变量的命名规则</h3><ul>
<li>变量名称可以包含数字和字母。</li>
<li>除了下划线 <strong>_</strong> 和美元 <strong>$</strong> 符号外，不能包含其他特殊字符，包括空格。</li>
<li>变量名不能以数字开头。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [变量名] : [类型] = 值;</span><br><span class="line"><span class="comment">// 声明变量没有设置类型和初始值，类型可以是任意类型，默认初始值为 undefined：</span></span><br></pre></td></tr></table></figure>
<h3 id="类型断言（Type-Assertion）"><a href="#类型断言（Type-Assertion）" class="headerlink" title="类型断言（Type Assertion）"></a>类型断言（Type Assertion）</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型&gt;值</span><br><span class="line">或</span><br><span class="line">值 <span class="keyword">as</span> 类型</span><br></pre></td></tr></table></figure>
<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>当类型没有给出时，TypeScript 编译器利用类型推断来推断类型。</p>
<p>如果由于缺乏声明而不能推断出类型，那么它的类型被视作默认的动态 any 类型</p>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>变量作用域指定了变量定义的位置。</p>
<p>程序中变量的可用性由变量作用域决定。</p>
<p>TypeScript 有以下几种作用域</p>
<ul>
<li><strong>全局作用域</strong> − 全局变量定义在程序结构的外部，它可以在你代码的任何位置使用。</li>
<li><strong>类作用域</strong> − 这个变量也可以称为 <strong>字段</strong>。类变量声明在一个类里头，但在类的方法外面。 该变量可以通过类的对象来访问。类变量也可以是静态的，静态的变量可以通过类名直接访问。</li>
<li><strong>局部作用域</strong> − 局部变量，局部变量只能在声明它的一个代码块（如：方法）中使用</li>
</ul>
<h2 id="TypeScript-运算符"><a href="#TypeScript-运算符" class="headerlink" title="TypeScript 运算符"></a>TypeScript 运算符</h2><ul>
<li>算术运算符</li>
<li>逻辑运算符</li>
<li>关系运算符</li>
<li>按位运算符</li>
<li>赋值运算符</li>
<li>三元/条件运算符</li>
<li>字符串运算符</li>
<li>类型运算符</li>
</ul>
<h3 id="类型运算符"><a href="#类型运算符" class="headerlink" title="类型运算符"></a>类型运算符</h3><h5 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h5><p>typeof 是一元运算符，返回操作数的数据类型</p>
<h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h5><p>instanceof 运算符用于判断对象是否为指定的类型</p>
<h2 id="TypeScript-条件语句"><a href="#TypeScript-条件语句" class="headerlink" title="TypeScript 条件语句"></a>TypeScript 条件语句</h2><ul>
<li><strong>if 语句</strong> - 只有当指定条件为 true 时，使用该语句来执行代码</li>
<li><strong>if…else 语句</strong> - 当条件为 true 时执行代码，当条件为 false 时执行其他代码</li>
<li><strong>if…else if….else 语句</strong>- 使用该语句来选择多个代码块之一来执行</li>
<li><strong>switch 语句</strong> - 使用该语句来选择多个代码块之一来执行</li>
</ul>
<h2 id="TypeScript-循环"><a href="#TypeScript-循环" class="headerlink" title="TypeScript 循环"></a>TypeScript 循环</h2><ul>
<li><strong>for 循环</strong></li>
<li><strong>for…in 循环</strong></li>
<li><strong>for…in 循环</strong></li>
<li><strong>while 循环</strong></li>
<li><strong>do…while 循环</strong></li>
<li><strong>break 语句</strong></li>
<li><strong>continue 语句</strong></li>
<li><strong>无限循环</strong></li>
</ul>
<h2 id="TypeScript-函数"><a href="#TypeScript-函数" class="headerlink" title="TypeScript 函数"></a>TypeScript 函数</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">function_name</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function_name()</span><br></pre></td></tr></table></figure>
<h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">function_name</span>(<span class="params"></span>):<span class="title">return_type</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">return</span> value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带参数函数"><a href="#带参数函数" class="headerlink" title="带参数函数"></a>带参数函数</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func_name</span>(<span class="params"> param1 [:datatype], param2 [:datatype]</span>) </span>&#123;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>在 TypeScript 函数里，如果我们定义了参数，则我们必须传入这些参数，除非将这些参数设置为可选，可选参数使用问号标识 ？。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastName)</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + lastName;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">&quot;Bob&quot;</span>);  <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>, <span class="string">&quot;Sr.&quot;</span>);  <span class="comment">// 错误，参数太多了</span></span><br><span class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>);  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">function_name</span>(<span class="params">param1[:<span class="keyword">type</span>],param2[:<span class="keyword">type</span>] = default_value</span>) </span>&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>有一种情况，我们不知道要向函数传入多少个参数，这时候我们就可以使用剩余参数来定义。</p>
<p>剩余参数语法允许我们将一个不确定数量的参数作为一个数组传入。</p>
<p>函数的最后一个命名参数 restOfName 以 … 为前缀，它将成为一个由剩余参数组成的数组，索引值从0（包括）到 restOfName.length（不包括）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + restOfName.join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> employeeName = buildName(<span class="string">&quot;Joseph&quot;</span>, <span class="string">&quot;Samuel&quot;</span>, <span class="string">&quot;Lucas&quot;</span>, <span class="string">&quot;MacKinzie&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>匿名函数是一个没有函数名的函数。</p>
<p>匿名函数在程序运行时动态声明，除了没有函数名外，其他的与标准函数一样。</p>
<p>我们可以将匿名函数赋值给一个变量，这种表达式就成为函数表达式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="function"><span class="keyword">function</span>(<span class="params"> [<span class="built_in">arguments</span>] </span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h4 id="匿名函数自调用"><a href="#匿名函数自调用" class="headerlink" title="匿名函数自调用"></a>匿名函数自调用</h4><p>匿名函数自调用在函数后使用 () 即可</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">&quot;Hello!!&quot;</span>;   </span><br><span class="line">    <span class="built_in">console</span>.log(x)     </span><br><span class="line"> &#125;)()</span><br></pre></td></tr></table></figure>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>TypeScript 也支持使用 JavaScript 内置的构造函数 Function() 来定义函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="keyword">new</span> <span class="built_in">Function</span> ([arg1[, arg2[, ...argN]],] functionBody)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>arg1, arg2, … argN</strong>：参数列表。</li>
<li><strong>functionBody</strong>：一个含有包括函数定义的 JavaScript 语句的字符串。</li>
</ul>
<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params"><span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">number</span> &lt;= <span class="number">0</span>) &#123;         <span class="comment">// 停止执行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;     </span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">number</span> * factorial(<span class="built_in">number</span> - <span class="number">1</span>));     <span class="comment">// 调用自身</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">6</span>));      <span class="comment">// 输出 720</span></span><br></pre></td></tr></table></figure>
<h3 id="Lambda-函数"><a href="#Lambda-函数" class="headerlink" title="Lambda 函数"></a>Lambda 函数</h3><p>Lambda 函数也称之为箭头函数。</p>
<p>箭头函数表达式的语法比函数表达式更短。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( [param1, parma2,…param n] )=&gt;statement;</span><br></pre></td></tr></table></figure>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>重载是方法名字相同，而参数不同，返回类型可以相同也可以不同。</p>
<p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>
<p>如果参数类型不同，则参数类型应设置为 <strong>any</strong>。</p>
<p>参数数量不同你可以将不同的参数设置为可选。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数类型不同</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">disp</span>(<span class="params"><span class="built_in">string</span></span>):<span class="title">void</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">disp</span>(<span class="params"><span class="built_in">number</span></span>):<span class="title">void</span></span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//参数数量不同</span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">disp</span>(<span class="params">n1:<span class="built_in">number</span></span>):<span class="title">void</span></span>; </span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">disp</span>(<span class="params">x:<span class="built_in">number</span>,y:<span class="built_in">number</span></span>):<span class="title">void</span></span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//参数类型顺序不同</span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">disp</span>(<span class="params">n1:<span class="built_in">number</span>,s1:<span class="built_in">string</span></span>):<span class="title">void</span></span>; </span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">disp</span>(<span class="params">s:<span class="built_in">string</span>,n:<span class="built_in">number</span></span>):<span class="title">void</span></span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="TypeScript-Number"><a href="#TypeScript-Number" class="headerlink" title="TypeScript Number"></a>TypeScript Number</h2><p>TypeScript 与 JavaScript 类似，支持 Number 对象。</p>
<p>Number 对象是原始数值的包装对象。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(value);</span><br></pre></td></tr></table></figure>
<h3 id="Number-对象属性"><a href="#Number-对象属性" class="headerlink" title="Number 对象属性"></a>Number 对象属性</h3><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">属性 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1.</td>
<td align="center"><strong>MAX_VALUE</strong>可表示的最大的数，MAX_VALUE 属性值接近于 1.79E+308。大于 MAX_VALUE 的值代表 “Infinity”。</td>
</tr>
<tr>
<td align="center">2.</td>
<td align="center"><strong>MIN_VALUE</strong>可表示的最小的数，即最接近 0 的正数 (实际上不会变成 0)。最大的负数是 -MIN_VALUE，MIN_VALUE 的值约为 5e-324。小于 MIN_VALUE (“underflow values”) 的值将会转换为 0。</td>
</tr>
<tr>
<td align="center">3.</td>
<td align="center"><strong>NaN</strong>非数字值（Not-A-Number）。</td>
</tr>
<tr>
<td align="center">4.</td>
<td align="center"><strong>NEGATIVE_INFINITY</strong>负无穷大，溢出时返回该值。该值小于 MIN_VALUE。</td>
</tr>
<tr>
<td align="center">5.</td>
<td align="center"><strong>POSITIVE_INFINITY</strong>正无穷大，溢出时返回该值。该值大于 MAX_VALUE。</td>
</tr>
<tr>
<td align="center">6.</td>
<td align="center"><strong>prototype</strong>Number 对象的静态属性。使您有能力向对象添加属性和方法。</td>
</tr>
<tr>
<td align="center">7.</td>
<td align="center"><strong>constructor</strong>返回对创建此对象的 Number 函数的引用。</td>
</tr>
</tbody></table>
<h3 id="Number-对象方法"><a href="#Number-对象方法" class="headerlink" title="Number 对象方法"></a>Number 对象方法</h3><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">方法 &amp; 描述</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1.</td>
<td align="center">toExponential()把对象的值转换为指数计数法。</td>
<td align="center"><code>//toExponential()  var num1 = 1225.30  var val = num1.toExponential();  console.log(val) // 输出： 1.2253e+3</code></td>
</tr>
<tr>
<td align="center">2.</td>
<td align="center">toFixed()把数字转换为字符串，并对小数点指定位数。</td>
<td align="center"><code>var num3 = 177.234  console.log(&quot;num3.toFixed() 为 &quot;+num3.toFixed())    // 输出：177 console.log(&quot;num3.toFixed(2) 为 &quot;+num3.toFixed(2))  // 输出：177.23 console.log(&quot;num3.toFixed(6) 为 &quot;+num3.toFixed(6))  // 输出：177.234000</code></td>
</tr>
<tr>
<td align="center">3.</td>
<td align="center">toLocaleString()把数字转换为字符串，使用本地数字格式顺序。</td>
<td align="center"><code>var num = new Number(177.1234);  console.log( num.toLocaleString());  // 输出：177.1234</code></td>
</tr>
<tr>
<td align="center">4.</td>
<td align="center">toPrecision()把数字格式化为指定的长度。</td>
<td align="center"><code>var num = new Number(7.123456);  console.log(num.toPrecision());  // 输出：7.123456  console.log(num.toPrecision(1)); // 输出：7 console.log(num.toPrecision(2)); // 输出：7.1</code></td>
</tr>
<tr>
<td align="center">5.</td>
<td align="center">toString()把数字转换为字符串，使用指定的基数。数字的基数是 2 ~ 36 之间的整数。若省略该参数，则使用基数 10。</td>
<td align="center"><code>var num = new Number(10);  console.log(num.toString());  // 输出10进制：10 console.log(num.toString(2)); // 输出2进制：1010 console.log(num.toString(8)); // 输出8进制：12</code></td>
</tr>
<tr>
<td align="center">6.</td>
<td align="center">valueOf()返回一个 Number 对象的原始数字值。</td>
<td align="center"><code>var num = new Number(10);  console.log(num.valueOf()); // 输出：10</code></td>
</tr>
</tbody></table>
<h2 id="TypeScript-String（字符串）"><a href="#TypeScript-String（字符串）" class="headerlink" title="TypeScript String（字符串）"></a>TypeScript String（字符串）</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> txt = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">或者更简单方式：</span><br><span class="line"><span class="keyword">var</span> txt = <span class="string">&quot;string&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="String-对象属性"><a href="#String-对象属性" class="headerlink" title="String 对象属性"></a>String 对象属性</h3><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">属性 &amp; 描述</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1.</td>
<td align="center">constructor对创建该对象的函数的引用。</td>
<td align="center"><code>var str = new String( &quot;This is string&quot; );  console.log(&quot;str.constructor is:&quot; + str.constructor)</code>输出结果：<code>str.constructor is:function String() &#123; [native code] &#125;</code></td>
</tr>
<tr>
<td align="center">2.</td>
<td align="center">length返回字符串的长度。</td>
<td align="center"><code>var uname = new String(&quot;Hello World&quot;)  console.log(&quot;Length &quot;+uname.length)  // 输出 11</code></td>
</tr>
<tr>
<td align="center">3.</td>
<td align="center">prototype允许您向对象添加属性和方法。</td>
<td align="center"><code>function employee(id:number,name:string) &#123;     this.id = id     this.name = name  &#125;  var emp = new employee(123,&quot;admin&quot;)  employee.prototype.email=&quot;admin@runoob.com&quot; // 添加属性 email console.log(&quot;员工号: &quot;+emp.id)  console.log(&quot;员工姓名: &quot;+emp.name)  console.log(&quot;员工邮箱: &quot;+emp.email)</code></td>
</tr>
</tbody></table>
<h3 id="String-方法"><a href="#String-方法" class="headerlink" title="String 方法"></a>String 方法</h3><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">属性 &amp; 描述</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1.</td>
<td align="center">constructor对创建该对象的函数的引用。</td>
<td align="center"><code>var str = new String( &quot;This is string&quot; );  console.log(&quot;str.constructor is:&quot; + str.constructor)</code>输出结果：<code>str.constructor is:function String() &#123; [native code] &#125;</code></td>
</tr>
<tr>
<td align="center">2.</td>
<td align="center">length返回字符串的长度。</td>
<td align="center"><code>var uname = new String(&quot;Hello World&quot;)  console.log(&quot;Length &quot;+uname.length)  // 输出 11</code></td>
</tr>
<tr>
<td align="center">3.</td>
<td align="center">prototype允许您向对象添加属性和方法。</td>
<td align="center"><code>function employee(id:number,name:string) &#123;     this.id = id     this.name = name  &#125;  var emp = new employee(123,&quot;admin&quot;)  employee.prototype.email=&quot;admin@runoob.com&quot; // 添加属性 email console.log(&quot;员工号: &quot;+emp.id)  console.log(&quot;员工姓名: &quot;+emp.name)  console.log(&quot;员工邮箱: &quot;+emp.email)</code></td>
</tr>
</tbody></table>
<h3 id="String-方法-1"><a href="#String-方法-1" class="headerlink" title="String 方法"></a>String 方法</h3><p>下表列出了 String 对象支持的方法：</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">方法 &amp; 描述</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1.</td>
<td align="center">charAt()返回在指定位置的字符。</td>
<td align="center"><code>var str = new String(&quot;RUNOOB&quot;);  console.log(&quot;str.charAt(0) 为:&quot; + str.charAt(0)); // R console.log(&quot;str.charAt(1) 为:&quot; + str.charAt(1)); // U  console.log(&quot;str.charAt(2) 为:&quot; + str.charAt(2)); // N  console.log(&quot;str.charAt(3) 为:&quot; + str.charAt(3)); // O  console.log(&quot;str.charAt(4) 为:&quot; + str.charAt(4)); // O  console.log(&quot;str.charAt(5) 为:&quot; + str.charAt(5)); // B</code></td>
</tr>
<tr>
<td align="center">2.</td>
<td align="center">charCodeAt()返回在指定的位置的字符的 Unicode 编码。</td>
<td align="center"><code>var str = new String(&quot;RUNOOB&quot;);  console.log(&quot;str.charCodeAt(0) 为:&quot; + str.charCodeAt(0)); // 82 console.log(&quot;str.charCodeAt(1) 为:&quot; + str.charCodeAt(1)); // 85  console.log(&quot;str.charCodeAt(2) 为:&quot; + str.charCodeAt(2)); // 78  console.log(&quot;str.charCodeAt(3) 为:&quot; + str.charCodeAt(3)); // 79  console.log(&quot;str.charCodeAt(4) 为:&quot; + str.charCodeAt(4)); // 79 console.log(&quot;str.charCodeAt(5) 为:&quot; + str.charCodeAt(5)); // 66</code></td>
</tr>
<tr>
<td align="center">3.</td>
<td align="center">concat()连接两个或更多字符串，并返回新的字符串。</td>
<td align="center"><code>var str1 = new String( &quot;RUNOOB&quot; );  var str2 = new String( &quot;GOOGLE&quot; );  var str3 = str1.concat( str2 );  console.log(&quot;str1 + str2 : &quot;+str3) // RUNOOBGOOGLE</code></td>
</tr>
<tr>
<td align="center">4.</td>
<td align="center">indexOf()返回某个指定的字符串值在字符串中首次出现的位置。</td>
<td align="center"><code>var str1 = new String( &quot;RUNOOB&quot; );  var index = str1.indexOf( &quot;OO&quot; );  console.log(&quot;查找的字符串位置 :&quot; + index );  // 3</code></td>
</tr>
<tr>
<td align="center">5.</td>
<td align="center">lastIndexOf()从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置。</td>
<td align="center"><code>var str1 = new String( &quot;This is string one and again string&quot; );  var index = str1.lastIndexOf( &quot;string&quot; ); console.log(&quot;lastIndexOf 查找到的最后字符串位置 :&quot; + index ); // 29     index = str1.lastIndexOf( &quot;one&quot; );  console.log(&quot;lastIndexOf 查找到的最后字符串位置 :&quot; + index ); // 15</code></td>
</tr>
<tr>
<td align="center">6.</td>
<td align="center">localeCompare()用本地特定的顺序来比较两个字符串。</td>
<td align="center"><code>var str1 = new String( &quot;This is beautiful string&quot; );   var index = str1.localeCompare( &quot;This is beautiful string&quot;);   console.log(&quot;localeCompare first :&quot; + index );  // 0</code></td>
</tr>
<tr>
<td align="center">7.</td>
<td align="center">**match()**查找找到一个或多个正则表达式的匹配。</td>
<td align="center"><code>var str=&quot;The rain in SPAIN stays mainly in the plain&quot;;  var n=str.match(/ain/g);  // ain,ain,ain</code></td>
</tr>
<tr>
<td align="center">8.</td>
<td align="center">replace()替换与正则表达式匹配的子串</td>
<td align="center"><code>var re = /(\w+)\s(\w+)/;  var str = &quot;zara ali&quot;;  var newstr = str.replace(re, &quot;$2, $1&quot;);  console.log(newstr); // ali, zara</code></td>
</tr>
<tr>
<td align="center">9.</td>
<td align="center">search()检索与正则表达式相匹配的值</td>
<td align="center"><code>var re = /apples/gi;  var str = &quot;Apples are round, and apples are juicy.&quot;; if (str.search(re) == -1 ) &#123;    console.log(&quot;Does not contain Apples&quot; );  &#125; else &#123;    console.log(&quot;Contains Apples&quot; );  &#125; </code></td>
</tr>
<tr>
<td align="center">10.</td>
<td align="center">slice()提取字符串的片断，并在新的字符串中返回被提取的部分。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">11.</td>
<td align="center">split()把字符串分割为子字符串数组。</td>
<td align="center"><code>var str = &quot;Apples are round, and apples are juicy.&quot;;  var splitted = str.split(&quot; &quot;, 3);  console.log(splitted)  // [ &#39;Apples&#39;, &#39;are&#39;, &#39;round,&#39; ]</code></td>
</tr>
<tr>
<td align="center">12.</td>
<td align="center">substr()从起始索引号提取字符串中指定数目的字符。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">13.</td>
<td align="center">substring()提取字符串中两个指定的索引号之间的字符。</td>
<td align="center"><code>var str = &quot;RUNOOB GOOGLE TAOBAO FACEBOOK&quot;;  console.log(&quot;(1,2): &quot;    + str.substring(1,2));   // U console.log(&quot;(0,10): &quot;   + str.substring(0, 10)); // RUNOOB GOO console.log(&quot;(5): &quot;      + str.substring(5));     // B GOOGLE TAOBAO FACEBOOK</code></td>
</tr>
<tr>
<td align="center">14.</td>
<td align="center">toLocaleLowerCase()根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射。</td>
<td align="center"><code>var str = &quot;Runoob Google&quot;;  console.log(str.toLocaleLowerCase( ));  // runoob google</code></td>
</tr>
<tr>
<td align="center">15.</td>
<td align="center">toLocaleUpperCase()据主机的语言环境把字符串转换为大写，只有几种语言（如土耳其语）具有地方特有的大小写映射。</td>
<td align="center"><code>var str = &quot;Runoob Google&quot;;  console.log(str.toLocaleUpperCase( ));  // RUNOOB GOOGLE</code></td>
</tr>
<tr>
<td align="center">16.</td>
<td align="center">toLowerCase()把字符串转换为小写。</td>
<td align="center"><code>var str = &quot;Runoob Google&quot;;  console.log(str.toLowerCase( ));  // runoob google</code></td>
</tr>
<tr>
<td align="center">17.</td>
<td align="center">toString()返回字符串。</td>
<td align="center"><code>var str = &quot;Runoob&quot;;  console.log(str.toString( )); // Runoob</code></td>
</tr>
<tr>
<td align="center">18.</td>
<td align="center">toUpperCase()把字符串转换为大写。</td>
<td align="center"><code>var str = &quot;Runoob Google&quot;;  console.log(str.toUpperCase( ));  // RUNOOB GOOGLE</code></td>
</tr>
<tr>
<td align="center">19.</td>
<td align="center">valueOf()返回指定字符串对象的原始值。</td>
<td align="center"><code>var str = new String(&quot;Runoob&quot;);  console.log(str.valueOf( ));  // Runoob</code></td>
</tr>
</tbody></table>
<h2 id="TypeScript-Array-数组"><a href="#TypeScript-Array-数组" class="headerlink" title="TypeScript Array(数组)"></a>TypeScript Array(数组)</h2><p>如果数组声明时未设置类型，则会被认为是 any 类型，在初始化时根据第一个元素的类型来推断数组的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array_name[:datatype];        <span class="comment">//声明 </span></span><br><span class="line">array_name = [val1,val2,valn..]   <span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">var</span> array_name[:data <span class="keyword">type</span>] = [val1,val2…valn]</span><br></pre></td></tr></table></figure>
<h3 id="Array-对象"><a href="#Array-对象" class="headerlink" title="Array 对象"></a>Array 对象</h3><p>我们也可以使用 Array 对象创建数组。</p>
<p>Array 对象的构造函数接受以下两种值：</p>
<ul>
<li>表示数组大小的数值。</li>
<li>初始化的数组列表，元素使用逗号分隔值。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr_names:<span class="built_in">number</span>[] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;arr_names.length; i++) &#123; </span><br><span class="line">        arr_names[i] = i * <span class="number">2</span> </span><br><span class="line">        <span class="built_in">console</span>.log(arr_names[i]) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><p>我们也可以把数组元素赋值给变量</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr:<span class="built_in">number</span>[] = [<span class="number">12</span>,<span class="number">13</span>] </span><br><span class="line"><span class="keyword">var</span>[x,y] = arr <span class="comment">// 将数组的两个元素赋值给变量 x 和 y</span></span><br><span class="line"><span class="built_in">console</span>.log(x) </span><br><span class="line"><span class="built_in">console</span>.log(y)</span><br></pre></td></tr></table></figure>
<h3 id="数组迭代"><a href="#数组迭代" class="headerlink" title="数组迭代"></a>数组迭代</h3><p>我们可以使用 for 语句来循环输出数组的各个元素</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> j:<span class="built_in">any</span>; </span><br><span class="line"><span class="keyword">var</span> nums:<span class="built_in">number</span>[] = [<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>] </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(j <span class="keyword">in</span> nums) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(nums[j]) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>一个数组的元素可以是另外一个数组，这样就构成了多维数组（Multi-dimensional Array）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr_name:datatype[][]=[ [val1,val2,val3],[v1,v2,v3] ]</span><br></pre></td></tr></table></figure>
<h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">方法 &amp; 描述</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1.</td>
<td align="center">concat()连接两个或更多的数组，并返回结果。</td>
<td align="center"><code>var alpha = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];  var numeric = [1, 2, 3]; var alphaNumeric = alpha.concat(numeric);  console.log(&quot;alphaNumeric : &quot; + alphaNumeric );    // a,b,c,1,2,3   </code></td>
</tr>
<tr>
<td align="center">2.</td>
<td align="center">every()检测数值元素的每个元素是否都符合条件。</td>
<td align="center"><code>function isBigEnough(element, index, array) &#123;         return (element &gt;= 10);  &#125;          var passed = [12, 5, 8, 130, 44].every(isBigEnough);  console.log(&quot;Test Value : &quot; + passed ); // false</code></td>
</tr>
<tr>
<td align="center">3.</td>
<td align="center">filter()检测数值元素，并返回符合条件所有元素的数组。</td>
<td align="center"><code>function isBigEnough(element, index, array) &#123;    return (element &gt;= 10);  &#125;            var passed = [12, 5, 8, 130, 44].filter(isBigEnough);  console.log(&quot;Test Value : &quot; + passed ); // 12,130,44</code></td>
</tr>
<tr>
<td align="center">4.</td>
<td align="center">forEach()数组每个元素都执行一次回调函数。</td>
<td align="center"><code>let num = [7, 8, 9]; num.forEach(function (value) &#123;    console.log(value); &#125;); </code>编译成 JavaScript 代码：<code>var num = [7, 8, 9]; num.forEach(function (value) &#123;    console.log(value);  // 7   8   9 &#125;);</code></td>
</tr>
<tr>
<td align="center">5.</td>
<td align="center">indexOf()搜索数组中的元素，并返回它所在的位置。如果搜索不到，返回值 -1，代表没有此项。</td>
<td align="center"><code>var index = [12, 5, 8, 130, 44].indexOf(8);  console.log(&quot;index is : &quot; + index );  // 2</code></td>
</tr>
<tr>
<td align="center">6.</td>
<td align="center">join()把数组的所有元素放入一个字符串。</td>
<td align="center"><code>var arr = new Array(&quot;First&quot;,&quot;Second&quot;,&quot;Third&quot;);            var str = arr.join();  console.log(&quot;str : &quot; + str );  // First,Second,Third            var str = arr.join(&quot;, &quot;);  console.log(&quot;str : &quot; + str );  // First, Second, Third           var str = arr.join(&quot; + &quot;);  console.log(&quot;str : &quot; + str );  // First + Second + Third</code></td>
</tr>
<tr>
<td align="center">7.</td>
<td align="center">lastIndexOf()返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。</td>
<td align="center"><code>var index = [12, 5, 8, 130, 44].lastIndexOf(8);  console.log(&quot;index is : &quot; + index );  // 2</code></td>
</tr>
<tr>
<td align="center">8.</td>
<td align="center">map()通过指定函数处理数组的每个元素，并返回处理后的数组。</td>
<td align="center"><code>var numbers = [1, 4, 9];  var roots = numbers.map(Math.sqrt);  console.log(&quot;roots is : &quot; + roots );  // 1,2,3</code></td>
</tr>
<tr>
<td align="center">9.</td>
<td align="center">pop()删除数组的最后一个元素并返回删除的元素。</td>
<td align="center"><code>var numbers = [1, 4, 9];            var element = numbers.pop();  console.log(&quot;element is : &quot; + element );  // 9           var element = numbers.pop();  console.log(&quot;element is : &quot; + element );  // 4</code></td>
</tr>
<tr>
<td align="center">10.</td>
<td align="center">push()向数组的末尾添加一个或更多元素，并返回新的长度。</td>
<td align="center"><code>var numbers = new Array(1, 4, 9);  var length = numbers.push(10);  console.log(&quot;new numbers is : &quot; + numbers );  // 1,4,9,10  length = numbers.push(20);  console.log(&quot;new numbers is : &quot; + numbers );  // 1,4,9,10,20</code></td>
</tr>
<tr>
<td align="center">11.</td>
<td align="center">reduce()将数组元素计算为一个值（从左到右）。</td>
<td align="center"><code>var total = [0, 1, 2, 3].reduce(function(a, b)&#123; return a + b; &#125;);  console.log(&quot;total is : &quot; + total );  // 6</code></td>
</tr>
<tr>
<td align="center">12.</td>
<td align="center">reduceRight()将数组元素计算为一个值（从右到左）。</td>
<td align="center"><code>var total = [0, 1, 2, 3].reduceRight(function(a, b)&#123; return a + b; &#125;);  console.log(&quot;total is : &quot; + total );  // 6</code></td>
</tr>
<tr>
<td align="center">13.</td>
<td align="center">reverse()反转数组的元素顺序。</td>
<td align="center"><code>var arr = [0, 1, 2, 3].reverse();  console.log(&quot;Reversed array is : &quot; + arr );  // 3,2,1,0</code></td>
</tr>
<tr>
<td align="center">14.</td>
<td align="center">shift()删除并返回数组的第一个元素。</td>
<td align="center"><code>var arr = [10, 1, 2, 3].shift();  console.log(&quot;Shifted value is : &quot; + arr );  // 10</code></td>
</tr>
<tr>
<td align="center">15.</td>
<td align="center">slice()选取数组的的一部分，并返回一个新数组。</td>
<td align="center"><code>var arr = [&quot;orange&quot;, &quot;mango&quot;, &quot;banana&quot;, &quot;sugar&quot;, &quot;tea&quot;];  console.log(&quot;arr.slice( 1, 2) : &quot; + arr.slice( 1, 2) );  // mango console.log(&quot;arr.slice( 1, 3) : &quot; + arr.slice( 1, 3) );  // mango,banana</code></td>
</tr>
<tr>
<td align="center">16.</td>
<td align="center">some()检测数组元素中是否有元素符合指定条件。</td>
<td align="center"><code>function isBigEnough(element, index, array) &#123;    return (element &gt;= 10);            &#125;            var retval = [2, 5, 8, 1, 4].some(isBigEnough); console.log(&quot;Returned value is : &quot; + retval );  // false           var retval = [12, 5, 8, 1, 4].some(isBigEnough);  console.log(&quot;Returned value is : &quot; + retval );  // true</code></td>
</tr>
<tr>
<td align="center">17.</td>
<td align="center">sort()对数组的元素进行排序。</td>
<td align="center"><code>var arr = new Array(&quot;orange&quot;, &quot;mango&quot;, &quot;banana&quot;, &quot;sugar&quot;);  var sorted = arr.sort();  console.log(&quot;Returned string is : &quot; + sorted );  // banana,mango,orange,sugar</code></td>
</tr>
<tr>
<td align="center">18.</td>
<td align="center">splice()从数组中添加或删除元素。</td>
<td align="center"><code>var arr = [&quot;orange&quot;, &quot;mango&quot;, &quot;banana&quot;, &quot;sugar&quot;, &quot;tea&quot;];   var removed = arr.splice(2, 0, &quot;water&quot;);   console.log(&quot;After adding 1: &quot; + arr );    // orange,mango,water,banana,sugar,tea  console.log(&quot;removed is: &quot; + removed);            removed = arr.splice(3, 1);   console.log(&quot;After removing 1: &quot; + arr );  // orange,mango,water,sugar,tea  console.log(&quot;removed is: &quot; + removed);  // banana</code></td>
</tr>
<tr>
<td align="center">19.</td>
<td align="center">toString()把数组转换为字符串，并返回结果。</td>
<td align="center"><code>var arr = new Array(&quot;orange&quot;, &quot;mango&quot;, &quot;banana&quot;, &quot;sugar&quot;);          var str = arr.toString();  console.log(&quot;Returned string is : &quot; + str );  // orange,mango,banana,sugar</code></td>
</tr>
<tr>
<td align="center">20.</td>
<td align="center">unshift()向数组的开头添加一个或更多元素，并返回新的长度。</td>
<td align="center"><code>var arr = new Array(&quot;orange&quot;, &quot;mango&quot;, &quot;banana&quot;, &quot;sugar&quot;);  var length = arr.unshift(&quot;water&quot;);  console.log(&quot;Returned array is : &quot; + arr );  // water,orange,mango,banana,sugar  console.log(&quot;Length of the array is : &quot; + length ); // 5</code></td>
</tr>
</tbody></table>
<h2 id="TypeScript-Map-对象"><a href="#TypeScript-Map-对象" class="headerlink" title="TypeScript Map 对象"></a>TypeScript Map 对象</h2><p>Map 对象保存键值对，并且能够记住键的原始插入顺序。</p>
<p>任何值(对象或者原始值) 都可以作为一个键或一个值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br></pre></td></tr></table></figure>
<p>Map 相关的函数与属性：</p>
<ul>
<li><strong>map.clear()</strong> – 移除 Map 对象的所有键/值对 。</li>
<li><strong>map.set()</strong> – 设置键值对，返回该 Map 对象。</li>
<li><strong>map.get()</strong> – 返回键对应的值，如果不存在，则返回 undefined。</li>
<li><strong>map.has()</strong> – 返回一个布尔值，用于判断 Map 中是否包含键对应的值。</li>
<li><strong>map.delete()</strong> – 删除 Map 中的元素，删除成功返回 true，失败返回 false。</li>
<li><strong>map.size</strong> – 返回 Map 对象键/值对的数量。</li>
<li><strong>map.keys()</strong> - 返回一个 Iterator 对象， 包含了 Map 对象中每个元素的键 。</li>
<li><strong>map.values()</strong> – 返回一个新的Iterator对象，包含了Map对象中每个元素的值 。</li>
</ul>
<h3 id="迭代-Map"><a href="#迭代-Map" class="headerlink" title="迭代 Map"></a>迭代 Map</h3><p>Map 对象中的元素是按顺序插入的，我们可以迭代 Map 对象，每一次迭代返回 [key, value] 数组。</p>
<p>TypeScript使用 <strong>for…of</strong> 来实现迭代</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代 Map 中的 key</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> nameSiteMapping.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);                  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 迭代 Map 中的 value</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> nameSiteMapping.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TypeScript-元组"><a href="#TypeScript-元组" class="headerlink" title="TypeScript 元组"></a>TypeScript 元组</h2><p>数组中元素的数据类型都一般是相同的（any[] 类型的数组可以不同），如果存储的元素数据类型不同，则需要使用元组。</p>
<p>元组中允许存储不同类型的元素，元组可以作为参数传递给函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tuple_name = [value1,value2,value3,…value n]</span><br></pre></td></tr></table></figure>
<h3 id="访问元组"><a href="#访问元组" class="headerlink" title="访问元组"></a>访问元组</h3><p>元组中元素使用索引来访问，第一个元素的索引值为 0，第二个为 1，以此类推第 n 个为 n-1，语法格式如下</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple_name[index]</span><br></pre></td></tr></table></figure>
<h3 id="元组运算"><a href="#元组运算" class="headerlink" title="元组运算"></a>元组运算</h3><p>我们可以使用以下两个函数向元组添加新元素或者删除元素：</p>
<ul>
<li>push() 向元组添加元素，添加在最后面。</li>
<li>pop() 从元组中移除元素（最后一个），并返回移除的元素</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mytuple = [<span class="number">10</span>,<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;World&quot;</span>,<span class="string">&quot;typeScript&quot;</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;添加前元素个数：&quot;</span>+mytuple.length)    <span class="comment">// 返回元组的大小</span></span><br><span class="line"> </span><br><span class="line">mytuple.push(<span class="number">12</span>)                                    <span class="comment">// 添加到元组中</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;添加后元素个数：&quot;</span>+mytuple.length) </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;删除前元素个数：&quot;</span>+mytuple.length) </span><br><span class="line"><span class="built_in">console</span>.log(mytuple.pop()+<span class="string">&quot; 元素从元组中删除&quot;</span>) <span class="comment">// 删除并返回删除的元素</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;删除后元素个数：&quot;</span>+mytuple.length)</span><br></pre></td></tr></table></figure>
<h3 id="更新元组"><a href="#更新元组" class="headerlink" title="更新元组"></a>更新元组</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mytuple = [<span class="number">10</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Taobao&quot;</span>, <span class="string">&quot;Google&quot;</span>]; <span class="comment">// 创建一个元组</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;元组的第一个元素为：&quot;</span> + mytuple[<span class="number">0</span>]) </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 更新元组元素</span></span><br><span class="line">mytuple[<span class="number">0</span>] = <span class="number">121</span>     </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;元组中的第一个元素更新为：&quot;</span>+ mytuple[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h3 id="解构元组"><a href="#解构元组" class="headerlink" title="解构元组"></a>解构元组</h3><p>我们也可以把元组元素赋值给变量</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a =[<span class="number">10</span>,<span class="string">&quot;Runoob&quot;</span>] </span><br><span class="line"><span class="keyword">var</span> [b,c] = a </span><br><span class="line"><span class="built_in">console</span>.log( b )    </span><br><span class="line"><span class="built_in">console</span>.log( c )</span><br></pre></td></tr></table></figure>
<h2 id="TypeScript-联合类型"><a href="#TypeScript-联合类型" class="headerlink" title="TypeScript 联合类型"></a>TypeScript 联合类型</h2><p>联合类型（Union Types）可以通过管道(|)将变量设置多种类型，赋值时可以根据设置的类型来赋值。</p>
<p><strong>注意</strong>：只能赋值指定的类型，如果赋值其它类型就会报错。</p>
<p>创建联合类型的语法格式如下</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type1|Type2|Type3 </span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> val:<span class="built_in">string</span>|<span class="built_in">number</span> </span><br><span class="line">val = <span class="number">12</span> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;数字为 &quot;</span>+ val) </span><br><span class="line">val = <span class="string">&quot;Runoob&quot;</span> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;字符串为 &quot;</span> + val)</span><br></pre></td></tr></table></figure>
<h3 id="联合类型数组"><a href="#联合类型数组" class="headerlink" title="联合类型数组"></a>联合类型数组</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr:<span class="built_in">number</span>[]|<span class="built_in">string</span>[]; </span><br><span class="line"><span class="keyword">var</span> i:<span class="built_in">number</span>; </span><br><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>] </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;**数字数组**&quot;</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;arr.length;i++) &#123; </span><br><span class="line">   <span class="built_in">console</span>.log(arr[i]) </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line">arr = [<span class="string">&quot;Runoob&quot;</span>,<span class="string">&quot;Google&quot;</span>,<span class="string">&quot;Taobao&quot;</span>] </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;**字符串数组**&quot;</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;arr.length;i++) &#123; </span><br><span class="line">   <span class="built_in">console</span>.log(arr[i]) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TypeScript-接口"><a href="#TypeScript-接口" class="headerlink" title="TypeScript 接口"></a>TypeScript 接口</h2><p>接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法。</p>
<p>TypeScript 接口定义如下</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> interface_name &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123; </span><br><span class="line">    firstName:<span class="built_in">string</span>, </span><br><span class="line">    lastName:<span class="built_in">string</span>, </span><br><span class="line">    sayHi: <span class="function">()=&gt;</span><span class="built_in">string</span> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> customer:IPerson = &#123; </span><br><span class="line">    firstName:<span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    lastName:<span class="string">&quot;Hanks&quot;</span>, </span><br><span class="line">    sayHi: ():<span class="function"><span class="params">string</span> =&gt;</span>&#123;<span class="keyword">return</span> <span class="string">&quot;Hi there&quot;</span>&#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="联合类型和接口"><a href="#联合类型和接口" class="headerlink" title="联合类型和接口"></a>联合类型和接口</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> RunOptions &#123; </span><br><span class="line">    program:<span class="built_in">string</span>; </span><br><span class="line">    commandline:<span class="built_in">string</span>[]|<span class="built_in">string</span>|(<span class="function">()=&gt;</span><span class="built_in">string</span>); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// commandline 是字符串</span></span><br><span class="line"><span class="keyword">var</span> options:RunOptions = &#123;<span class="attr">program</span>:<span class="string">&quot;test1&quot;</span>,<span class="attr">commandline</span>:<span class="string">&quot;Hello&quot;</span>&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(options.commandline)  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// commandline 是字符串数组</span></span><br><span class="line">options = &#123;<span class="attr">program</span>:<span class="string">&quot;test1&quot;</span>,<span class="attr">commandline</span>:[<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;World&quot;</span>]&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(options.commandline[<span class="number">0</span>]); </span><br><span class="line"><span class="built_in">console</span>.log(options.commandline[<span class="number">1</span>]);  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// commandline 是一个函数表达式</span></span><br><span class="line">options = &#123;<span class="attr">program</span>:<span class="string">&quot;test1&quot;</span>,<span class="attr">commandline</span>:<span class="function">()=&gt;</span>&#123;<span class="keyword">return</span> <span class="string">&quot;**Hello World**&quot;</span>;&#125;&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> fn:<span class="built_in">any</span> = options.commandline; </span><br><span class="line"><span class="built_in">console</span>.log(fn());</span><br></pre></td></tr></table></figure>
<h3 id="接口和数组"><a href="#接口和数组" class="headerlink" title="接口和数组"></a>接口和数组</h3><p>接口中我们可以将数组的索引值和元素设置为不同类型，索引值可以是数字或字符串</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> namelist &#123; </span><br><span class="line">   [index:<span class="built_in">number</span>]:<span class="built_in">string</span> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> list2:namelist = [<span class="string">&quot;John&quot;</span>,<span class="number">1</span>,<span class="string">&quot;Bran&quot;</span>] / 错误元素 <span class="number">1</span> 不是 <span class="built_in">string</span> 类型</span><br><span class="line"><span class="keyword">interface</span> ages &#123; </span><br><span class="line">   [index:<span class="built_in">string</span>]:<span class="built_in">number</span> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> agelist:ages; </span><br><span class="line">agelist[<span class="string">&quot;John&quot;</span>] = <span class="number">15</span>   <span class="comment">// 正确 </span></span><br><span class="line">agelist[<span class="number">2</span>] = <span class="string">&quot;nine&quot;</span>   <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>接口继承就是说接口可以通过其他接口来扩展自己。</p>
<p>Typescript 允许接口继承多个接口。</p>
<p>继承使用关键字 <strong>extends</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单接口继承语法格式</span></span><br><span class="line">Child_interface_name <span class="keyword">extends</span> super_interface_name</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多接口继承语法格式</span></span><br><span class="line">Child_interface_name <span class="keyword">extends</span> super_interface1_name, super_interface2_name,…,super_interfaceN_name</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123; </span><br><span class="line">   age:<span class="built_in">number</span> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> Musician <span class="keyword">extends</span> Person &#123; </span><br><span class="line">   instrument:<span class="built_in">string</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TypeScript-类"><a href="#TypeScript-类" class="headerlink" title="TypeScript 类"></a>TypeScript 类</h2><p>TypeScript 是面向对象的 JavaScript。</p>
<p>类描述了所创建的对象共同的属性和方法。</p>
<p>TypeScript 支持面向对象的所有特性，比如 类、接口等。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_name</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 类作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义类的关键字为 class，后面紧跟类名，类可以包含以下几个模块（类的数据成员）：</p>
<ul>
<li><strong>字段</strong> − 字段是类里面声明的变量。字段表示对象的有关数据。</li>
<li><strong>构造函数</strong> − 类实例化时调用，可以为类的对象分配内存。</li>
<li><strong>方法</strong> − 方法为对象要执行的操作。</li>
</ul>
<h3 id="创建类的数据成员"><a href="#创建类的数据成员" class="headerlink" title="创建类的数据成员"></a>创建类的数据成员</h3><p>以下实例我们声明了类 Car，包含字段为 engine，构造函数在类实例化后初始化字段 engine。</p>
<p>this 关键字表示当前类实例化的对象。注意构造函数的参数名与字段名相同，this.engine 表示类的字段。</p>
<p>此外我们也在类中定义了一个方法 disp()。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 字段 </span></span><br><span class="line">    engine:<span class="built_in">string</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 构造函数 </span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">engine:<span class="built_in">string</span></span>)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.engine = engine </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 方法 </span></span><br><span class="line">    disp():<span class="built_in">void</span> &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;发动机为 :   &quot;</span>+<span class="built_in">this</span>.engine) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建实例化对象"><a href="#创建实例化对象" class="headerlink" title="创建实例化对象"></a>创建实例化对象</h3><p>我们使用 new 关键字来实例化类的对象，语法格式如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object_name = <span class="keyword">new</span> class_name([ <span class="built_in">arguments</span> ])</span><br></pre></td></tr></table></figure>
<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>TypeScript 支持继承类，即我们可以在创建类的时候继承一个已存在的类，这个已存在的类称为父类，继承它的类称为子类。</p>
<p>类继承使用关键字 <strong>extends</strong>，子类除了不能继承父类的私有成员(方法和属性)和构造函数，其他的都可以继承。</p>
<p>TypeScript 一次只能继承一个类，不支持继承多个类，但 TypeScript 支持多重继承（A 继承 B，B 继承 C）。</p>
<p>语法格式如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">child_class_name</span> <span class="keyword">extends</span> <span class="title">parent_class_name</span></span></span><br></pre></td></tr></table></figure>
<h3 id="继承类的方法重写"><a href="#继承类的方法重写" class="headerlink" title="继承类的方法重写"></a>继承类的方法重写</h3><p>类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。</p>
<p>其中 super 关键字是对父类的直接引用，该关键字可以引用父类的属性和方法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrinterClass</span> </span>&#123; </span><br><span class="line">   doPrint():<span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;父类的 doPrint() 方法。&quot;</span>) </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringPrinter</span> <span class="keyword">extends</span> <span class="title">PrinterClass</span> </span>&#123; </span><br><span class="line">   doPrint():<span class="built_in">void</span> &#123; </span><br><span class="line">      <span class="built_in">super</span>.doPrint() <span class="comment">// 调用父类的函数</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;子类的 doPrint()方法。&quot;</span>)</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><p>static 关键字用于定义类的数据成员（属性和方法）为静态的，静态成员可以直接通过类名调用</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticMem</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">static</span> num:<span class="built_in">number</span>; </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">static</span> disp():<span class="built_in">void</span> &#123; </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;num 值为 &quot;</span>+ StaticMem.num) </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">StaticMem.num = <span class="number">12</span>     <span class="comment">// 初始化静态变量</span></span><br><span class="line">StaticMem.disp()       <span class="comment">// 调用静态方法</span></span><br></pre></td></tr></table></figure>
<h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p>instanceof 运算符用于判断对象是否是指定的类型，如果是返回 true，否则返回 false</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; &#125; </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person() </span><br><span class="line"><span class="keyword">var</span> isPerson = obj <span class="keyword">instanceof</span> Person; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;obj 对象是 Person 类实例化来的吗？ &quot;</span> + isPerson);</span><br></pre></td></tr></table></figure>
<h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><p>TypeScript 中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。TypeScript 支持 3 种不同的访问权限。</p>
<ul>
<li><strong>public（默认）</strong> : 公有，可以在任何地方被访问。</li>
<li><strong>protected</strong> : 受保护，可以被其自身以及其子类和父类访问。</li>
<li><strong>private</strong> : 私有，只能被其定义所在的类访问。</li>
</ul>
<p>以下实例定义了两个变量 str1 和 str2，str1 为 public，str2 为 private，实例化后可以访问 str1，如果要访问 str2 则会编译错误。</p>
<h3 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h3><p>类可以实现接口，使用关键字 implements，并将 interest 字段作为类的属性使用。</p>
<p>以下实例红 AgriLoan 类实现了 ILoan 接口</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ILoan &#123; </span><br><span class="line">   interest:<span class="built_in">number</span> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgriLoan</span> <span class="title">implements</span> <span class="title">ILoan</span> </span>&#123; </span><br><span class="line">   interest:<span class="built_in">number</span> </span><br><span class="line">   rebate:<span class="built_in">number</span> </span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="title">constructor</span>(<span class="params">interest:<span class="built_in">number</span>,rebate:<span class="built_in">number</span></span>)</span> &#123; </span><br><span class="line">      <span class="built_in">this</span>.interest = interest </span><br><span class="line">      <span class="built_in">this</span>.rebate = rebate </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="TypeScript-对象"><a href="#TypeScript-对象" class="headerlink" title="TypeScript 对象"></a>TypeScript 对象</h2><p>对象是包含一组键值对的实例。 值可以是标量、函数、数组、对象等，如下实例</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object_name = &#123; </span><br><span class="line">    key1: <span class="string">&quot;value1&quot;</span>, <span class="comment">// 标量</span></span><br><span class="line">    key2: <span class="string">&quot;value&quot;</span>,  </span><br><span class="line">    key3: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 函数</span></span><br><span class="line">    &#125;, </span><br><span class="line">    key4:[<span class="string">&quot;content1&quot;</span>, <span class="string">&quot;content2&quot;</span>] <span class="comment">//集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TypeScript-类型模板"><a href="#TypeScript-类型模板" class="headerlink" title="TypeScript 类型模板"></a>TypeScript 类型模板</h3><p>Typescript 中的对象必须是特定类型的实例</p>
<h3 id="鸭子类型-Duck-Typing"><a href="#鸭子类型-Duck-Typing" class="headerlink" title="鸭子类型(Duck Typing)"></a>鸭子类型(Duck Typing)</h3><p>鸭子类型（英语：duck typing）是动态类型的一种风格，是多态(polymorphism)的一种形式。</p>
<p>在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。</p>
<p>在鸭子类型中，关注点在于对象的行为，能作什么；而不是关注对象所属的类型。例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为”鸭子”的对象，并调用它的”走”和”叫”方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的”走”和”叫”方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的”走”和”叫”方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPoint &#123; </span><br><span class="line">    x:<span class="built_in">number</span> </span><br><span class="line">    y:<span class="built_in">number</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addPoints</span>(<span class="params">p1:IPoint,p2:IPoint</span>):<span class="title">IPoint</span> </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> x = p1.x + p2.x </span><br><span class="line">    <span class="keyword">var</span> y = p1.y + p2.y </span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">x</span>:x,<span class="attr">y</span>:y&#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> newPoint = addPoints(&#123;<span class="attr">x</span>:<span class="number">3</span>,<span class="attr">y</span>:<span class="number">4</span>&#125;,&#123;<span class="attr">x</span>:<span class="number">5</span>,<span class="attr">y</span>:<span class="number">1</span>&#125;)  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 错误 </span></span><br><span class="line"><span class="keyword">var</span> newPoint2 = addPoints(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;,&#123;<span class="attr">x</span>:<span class="number">4</span>,<span class="attr">y</span>:<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="TypeScript-命名空间"><a href="#TypeScript-命名空间" class="headerlink" title="TypeScript 命名空间"></a>TypeScript 命名空间</h2><p>命名空间一个最明确的目的就是解决重名问题。</p>
<p>假设这样一种情况，当一个班上有两个名叫小明的学生时，为了明确区分它们，我们在使用名字之外，不得不使用一些额外的信息，比如他们的姓（王小明，李小明），或者他们父母的名字等等。</p>
<p>命名空间定义了标识符的可见范围，一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的。这样，在一个新的名字空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其他名字空间中。</p>
<p>TypeScript 中命名空间使用 <strong>namespace</strong> 来定义，语法格式如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SomeNameSpaceName &#123; </span><br><span class="line">   <span class="keyword">export</span> <span class="keyword">interface</span> ISomeInterfaceName &#123;      &#125;  </span><br><span class="line">   <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeClassName</span> </span>&#123;      &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上定义了一个命名空间 SomeNameSpaceName，如果我们需要在外部可以调用 SomeNameSpaceName 中的类和接口，则需要在类和接口添加 <strong>export</strong> 关键字。</p>
<p>要在另外一个命名空间调用语法格式为：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SomeNameSpaceName.SomeClassName;</span><br></pre></td></tr></table></figure>
<p>如果一个命名空间在一个单独的 TypeScript 文件中，则应使用三斜杠 /// 引用它，语法格式如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path = &quot;SomeFileName.ts&quot; /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path = &quot;IShape.ts&quot; /&gt; </span></span><br><span class="line"><span class="keyword">namespace</span> Drawing &#123; </span><br><span class="line">    <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="title">implements</span> <span class="title">IShape</span> </span>&#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="title">draw</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;Circle is drawn&quot;</span>); </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="嵌套命名空间"><a href="#嵌套命名空间" class="headerlink" title="嵌套命名空间"></a>嵌套命名空间</h3><p>命名空间支持嵌套，即你可以将命名空间定义在另外一个命名空间里头</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> namespace_name1 &#123; </span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">namespace</span> namespace_name2 &#123;</span><br><span class="line">        <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">class_name</span> </span>&#123;    &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TypeScript-模块"><a href="#TypeScript-模块" class="headerlink" title="TypeScript 模块"></a>TypeScript 模块</h2><p>TypeScript 模块的设计理念是可以更换的组织代码。</p>
<p>模块是在其自身的作用域里执行，并不是在全局作用域，这意味着定义在模块里面的变量、函数和类等在模块外部是不可见的，除非明确地使用 export 导出它们。类似地，我们必须通过 import 导入其他模块导出的变量、函数、类等。</p>
<p>两个模块之间的关系是通过在文件级别上使用 import 和 export 建立的。</p>
<p>模块使用模块加载器去导入其它的模块。 在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。 大家最熟知的JavaScript模块加载器是服务于 Node.js 的 CommonJS 和服务于 Web 应用的 Require.js。</p>
<p>此外还有有 SystemJs 和 Webpack。</p>
<p>模块导出使用关键字 <strong>export</strong> 关键字，语法格式如下</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名 : SomeInterface.ts </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> SomeInterface &#123; </span><br><span class="line">   <span class="comment">// 代码部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要在另外一个文件使用该模块就需要使用 <strong>import</strong> 关键字来导入:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> someInterfaceRef = <span class="built_in">require</span>(<span class="string">&quot;./SomeInterface&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="TypeScript-声明文件"><a href="#TypeScript-声明文件" class="headerlink" title="TypeScript 声明文件"></a>TypeScript 声明文件</h2><p>TypeScript 作为 JavaScript 的超集，在开发过程中不可避免要引用其他第三方的 JavaScript 的库。虽然通过直接引用可以调用库的类和方法，但是却无法使用TypeScript 诸如类型检查等特性功能。为了解决这个问题，需要将这些库里的函数和方法体去掉后只保留导出类型声明，而产生了一个描述 JavaScript 库和模块信息的声明文件。通过引用这个声明文件，就可以借用 TypeScript 的各种特性来使用库文件了。</p>
<p>假如我们想使用第三方库，比如 jQuery，我们通常这样获取一个 id 是 foo 的元素：</p>
<p>使用 declare 关键字来定义它的类型，帮助 TypeScript 判断我们传入的参数类型对不对</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> jQuery: <span class="function">(<span class="params">selector: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">jQuery(<span class="string">&#x27;#foo&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h3><p>声明文件以 <strong>.d.ts</strong> 为后缀</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runoob.d.ts</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2020/12/21/TypeScript%E7%9F%A5%E8%AF%86%E7%82%B9/">http://example.com/2020/12/21/TypeScript%E7%9F%A5%E8%AF%86%E7%82%B9/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Hexo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2020/12/21/hello-world/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/null" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TypeScript%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">TypeScript知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.</span> <span class="toc-text">语言特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.</span> <span class="toc-text">安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="toc-number">1.2.1.</span> <span class="toc-text">命令行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">TypeScript 基础类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.4.</span> <span class="toc-text">TypeScript 变量声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TypeScript-%E5%8F%98%E9%87%8F%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-number">1.4.1.</span> <span class="toc-text">TypeScript 变量的命名规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%EF%BC%88Type-Assertion%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">类型断言（Type Assertion）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">1.4.3.</span> <span class="toc-text">类型推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.4.4.</span> <span class="toc-text">变量作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.</span> <span class="toc-text">TypeScript 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.1.</span> <span class="toc-text">类型运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#typeof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.1.0.1.</span> <span class="toc-text">typeof 运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#instanceof"><span class="toc-number">1.5.1.0.2.</span> <span class="toc-text">instanceof</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.6.</span> <span class="toc-text">TypeScript 条件语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.7.</span> <span class="toc-text">TypeScript 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.</span> <span class="toc-text">TypeScript 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">1.8.1.</span> <span class="toc-text">函数定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.2.</span> <span class="toc-text">调用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.8.3.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.4.</span> <span class="toc-text">带参数函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-number">1.8.5.</span> <span class="toc-text">可选参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">1.8.6.</span> <span class="toc-text">默认参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0"><span class="toc-number">1.8.7.</span> <span class="toc-text">剩余参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.8.</span> <span class="toc-text">匿名函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E8%87%AA%E8%B0%83%E7%94%A8"><span class="toc-number">1.8.8.1.</span> <span class="toc-text">匿名函数自调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.9.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.10.</span> <span class="toc-text">递归函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda-%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.11.</span> <span class="toc-text">Lambda 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">1.8.12.</span> <span class="toc-text">函数重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-Number"><span class="toc-number">1.9.</span> <span class="toc-text">TypeScript Number</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Number-%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7"><span class="toc-number">1.9.1.</span> <span class="toc-text">Number 对象属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Number-%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.2.</span> <span class="toc-text">Number 对象方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-String%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89"><span class="toc-number">1.10.</span> <span class="toc-text">TypeScript String（字符串）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7"><span class="toc-number">1.10.1.</span> <span class="toc-text">String 对象属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E6%96%B9%E6%B3%95"><span class="toc-number">1.10.2.</span> <span class="toc-text">String 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E6%96%B9%E6%B3%95-1"><span class="toc-number">1.10.3.</span> <span class="toc-text">String 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-Array-%E6%95%B0%E7%BB%84"><span class="toc-number">1.11.</span> <span class="toc-text">TypeScript Array(数组)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Array-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.11.1.</span> <span class="toc-text">Array 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84"><span class="toc-number">1.11.2.</span> <span class="toc-text">数组解构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.11.3.</span> <span class="toc-text">数组迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.11.4.</span> <span class="toc-text">多维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.11.5.</span> <span class="toc-text">数组方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-Map-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.12.</span> <span class="toc-text">TypeScript Map 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-Map"><span class="toc-number">1.12.1.</span> <span class="toc-text">迭代 Map</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-%E5%85%83%E7%BB%84"><span class="toc-number">1.13.</span> <span class="toc-text">TypeScript 元组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%BB%84"><span class="toc-number">1.13.1.</span> <span class="toc-text">访问元组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84%E8%BF%90%E7%AE%97"><span class="toc-number">1.13.2.</span> <span class="toc-text">元组运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E5%85%83%E7%BB%84"><span class="toc-number">1.13.3.</span> <span class="toc-text">更新元组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E5%85%83%E7%BB%84"><span class="toc-number">1.13.4.</span> <span class="toc-text">解构元组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.14.</span> <span class="toc-text">TypeScript 联合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-number">1.14.1.</span> <span class="toc-text">联合类型数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.15.</span> <span class="toc-text">TypeScript 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.15.1.</span> <span class="toc-text">联合类型和接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">1.15.2.</span> <span class="toc-text">接口和数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="toc-number">1.15.3.</span> <span class="toc-text">接口继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-%E7%B1%BB"><span class="toc-number">1.16.</span> <span class="toc-text">TypeScript 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B1%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">1.16.1.</span> <span class="toc-text">创建类的数据成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.16.2.</span> <span class="toc-text">创建实例化对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">1.16.3.</span> <span class="toc-text">类的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">1.16.4.</span> <span class="toc-text">继承类的方法重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.16.5.</span> <span class="toc-text">static 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.16.6.</span> <span class="toc-text">instanceof 运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.16.7.</span> <span class="toc-text">访问控制修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.16.8.</span> <span class="toc-text">类和接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.17.</span> <span class="toc-text">TypeScript 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TypeScript-%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.17.1.</span> <span class="toc-text">TypeScript 类型模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B-Duck-Typing"><span class="toc-number">1.17.2.</span> <span class="toc-text">鸭子类型(Duck Typing)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.18.</span> <span class="toc-text">TypeScript 命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.18.1.</span> <span class="toc-text">嵌套命名空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-%E6%A8%A1%E5%9D%97"><span class="toc-number">1.19.</span> <span class="toc-text">TypeScript 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6"><span class="toc-number">1.20.</span> <span class="toc-text">TypeScript 声明文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6"><span class="toc-number">1.20.1.</span> <span class="toc-text">声明文件</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2020/12/21/TypeScript%E7%9F%A5%E8%AF%86%E7%82%B9/" title="无题"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2020/12/21/TypeScript%E7%9F%A5%E8%AF%86%E7%82%B9/" title="无题">无题</a><time datetime="2020-12-21T06:47:11.062Z" title="发表于 2020-12-21 14:47:11">2020-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/21/hello-world/" title="Hello World"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2020/12/21/hello-world/" title="Hello World">Hello World</a><time datetime="2020-12-21T06:13:04.114Z" title="发表于 2020-12-21 14:13:04">2020-12-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By John Doe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>